<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="TangShusen">
<meta property="og:url" content="https://tangshusen.me/index.html">
<meta property="og:site_name" content="TangShusen">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TangShusen">






  <link rel="canonical" href="https://tangshusen.me/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>TangShusen</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">TangShusen</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tangshusen.me/2018/10/27/SVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TangShusen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/assets/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TangShusen">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/10/27/SVM/" class="post-title-link" itemprop="https://tangshusen.me/index.html">看了这篇文章你还不懂SVM你就来打我</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-27 23:19:45" itemprop="dateCreated datePublished" datetime="2018-10-27T23:19:45+08:00">2018-10-27</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-11-11 12:02:18" itemprop="dateModified" datetime="2018-11-11T12:02:18+08:00">2018-11-11</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Machine-Learning/" itemprop="url" rel="index"><span itemprop="name">Machine Learning</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h1 id="支持向量机-Support-Vector-Machine-SVM"><a href="#支持向量机-Support-Vector-Machine-SVM" class="headerlink" title="支持向量机(Support Vector Machine, SVM)"></a>支持向量机(Support Vector Machine, SVM)</h1><h2 id="1-概要"><a href="#1-概要" class="headerlink" title="1. 概要"></a>1. 概要</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><p>自从大半年前接触到SVM以来，感觉一直没怎么把SVM整明白。直到最近上的《模式识别》课程才仿佛打通了我的任督二脉，使我终于搞清楚了SVM的来龙去脉，所以写个博客作个总结。</p>
<p>SVM是什么? 先来看看维基百科上对<a href="https://zh.wikipedia.org/wiki/支持向量机" target="_blank" rel="noopener">SVM的定义</a>:</p>
<blockquote>
<p>支持向量机（英语：support vector machine，常简称为SVM，又名支持向量网络）是在分类与回归分析中分析数据的监督式学习模型与相关的学习算法。给定一组训练实例，每个训练实例被标记为属于两个类别中的一个或另一个，SVM训练算法创建一个将新的实例分配给两个类别之一的模型，使其成为非概率二元线性分类器。SVM模型是将实例表示为空间中的点，这样映射就使得单独类别的实例被尽可能宽的明显的间隔分开。然后，将新的实例映射到同一空间，并基于它们落在间隔的哪一侧来预测所属类别。</p>
</blockquote>
<p>如果从未接触SVM的话，维基的这一大段解释肯定会让你一头雾水。简单点讲，SVM就是一种二类分类模型，他的基本模型是的定义在特征空间上的<strong>间隔最大</strong>的线性分类器，SVM的学习策略就是间隔最大化。</p>
<h3 id="1-2-直观理解"><a href="#1-2-直观理解" class="headerlink" title="1.2 直观理解"></a>1.2 直观理解</h3><p>我们先来看看下面这个图:</p>
<center><br>    <img src="/2018/10/27/SVM/1.1.png" width="320" class="full-image" alt="Sample Image Added via Markdown"><br></center><br><center>图1.1</center>


<center><br>    <img src="/2018/10/27/SVM/1.1.png" width="320" class="full-image"><br>    <span class="image-caption" style="border-bottom: 1px solid #d9d9d9;
    color: #999;">图1.1</span><br></center>

<p><img src="/2018/10/27/SVM/1.1.png" alt="image-alt"></p>
<center>诶嘿</center>

<p><a href="http://stackexchange.com/users/17621" target="_blank" rel="noopener"><br>    <img src="/2018/10/27/SVM/1.1.png" width="300" alt="Alex Drenea's Stack Exchange profile" title="Alex Drenea's Stack Exchange profile"><br></a></p>
<p>图中有分别属于两类的一些二维数据点和三条直线。如果三条直线分别代表三个分类器的话，请问哪一个分类器比较好？</p>
<p>我们凭直观感受应该觉得答案是H3。首先H1不能把类别分开，这个分类器肯定是不行的；H2可以，但分割线与最近的数据点只有很小的间隔，如果测试数据有一些噪声的话可能就会被H2错误分类(即对噪声敏感、泛化能力弱)。H3以较大间隔将它们分开，这样就能容忍测试数据的一些噪声而正确分类，是一个泛化能力不错的分类器。</p>
<p>对于支持向量机来说，数据点若是$p$维向量，我们用$p-1$维的超平面来分开这些点。但是可能有许多超平面可以把数据分类。最佳超平面的一个合理选择就是以最大间隔把两个类分开的超平面。因此，SVM选择能够使离超平面最近的数据点的到超平面距离最大的超平面。</p>
<p>以上介绍的SVM只能解决线性可分的问题，为了解决更加复杂的问题，支持向量机学习方法有一些由简至繁的模型:</p>
<ul>
<li>线性可分SVM<blockquote>
<p>当训练数据线性可分时，通过硬间隔(hard margin，什么是硬、软间隔下面会讲)最大化可以学习得到一个线性分类器，即硬间隔SVM，如上图的的H3。</p>
</blockquote>
</li>
<li>线性SVM<blockquote>
<p>当训练数据不能线性可分但是可以近似线性可分时，通过软间隔(soft margin)最大化也可以学习到一个线性分类器，即软间隔SVM。</p>
</blockquote>
</li>
<li>非线性SVM<blockquote>
<p>当训练数据线性不可分时，通过使用核技巧(kernel trick)和软间隔最大化，可以学习到一个非线性SVM。</p>
</blockquote>
</li>
</ul>
<h2 id="2-线性可分SVM——硬间隔"><a href="#2-线性可分SVM——硬间隔" class="headerlink" title="2. 线性可分SVM——硬间隔"></a>2. 线性可分SVM——硬间隔</h2><p>考虑如下形式的<strong>线性可分</strong>的训练数据集:<br>$$<br>{(X_1,y_1),(X_2,y_2),…,(X_n,y_n)}<br>$$<br>其中 $X_i$是一个含有$d$个元素的列向量, 即$X_i\in \mathbf{R}^d$; $y_i$是标量, $y\in{+1,-1}$, $y_i = +1$时表示$X_i$属于正类别, $y_i = -1$时表示$X_i$属于负类别。</p>
<blockquote>
<p>注: 本文中, $X$、$X_i$、$W$等都是(列)向量，有的文章一般用 $x_i$ 表示一个向量而用 $X$ 表示所有 $x_i$ 组成的一个矩阵，注意区分。</p>
</blockquote>
<p>回忆一下感知机的目标: 找到一个超平面使其能正确地将每个样本正确分类。感知机使用误分类最小的方法求得超平面，不过此时解有无穷多个(例如图1.1的H2和H3以及它俩的任意线性组合)。而线性可分支持向量机利用间隔最大化求最优分离超平面,这时解是唯一的。</p>
<h3 id="2-1-超平面与间隔"><a href="#2-1-超平面与间隔" class="headerlink" title="2.1 超平面与间隔"></a>2.1 超平面与间隔</h3><p>一个超平面由法向量$W$和截距$b$决定,其方程为$X^TW+b=0$, 可以规定法向量指向的一侧为正类,另一侧为负类。下图画出了三个平行的超平面，法方向取左上方向。</p>
<blockquote>
<p>注意: 如果$X$和$W$都是列向量,即$X^TW$会得到$X$和$W$的点积(dot product, 是一个标量),等价于$X \cdot W$和$W \cdot X$。</p>
</blockquote>
<center><br>    <img src="/2018/10/27/SVM/2.1.png" width="400"><br>    <br><br>    <div style="border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;">图2.1</div><br></center>

<p>为了找到最大间隔超平面，我们可以先选择分离两类数据的两个平行超平面，使得它们之间的距离尽可能大。在这两个超平面范围内的区域称为“间隔(margin)”，最大间隔超平面是位于它们正中间的超平面。这个过程如上图所示。  </p>
<h3 id="2-2-间隔最大化"><a href="#2-2-间隔最大化" class="headerlink" title="2.2 间隔最大化"></a>2.2 间隔最大化</h3><p>将高数里面求两条平行直线的距离公式推广到高维可求得图2.1中margin的$\rho$:<br>$$<br>margin = \rho = \frac 2 {||W||} \tag{2.2.1}<br>$$<br>我们的目标是使$\rho$最大, 等价于使$\rho^2$最大:<br>$$<br>\underset{W,b}{max} \rho \iff \underset{W,b}{max} \rho^2 \iff \underset{W,b}{min}\frac 1 2 ||W||^2 \tag{2.2.2}<br>$$<br>上式的$\frac 1 2$是为了后续求导后刚好能消去，没有其他特殊意义。 </p>
<p>同时也不要忘了有一些约束条件:<br>$$<br>X_i^TW+b \ge +1, y_i=+1 \\\\<br>X_i^TW+b \le -1, y_i=-1 \tag{2.2.3}<br>$$<br>总结一下，间隔最大化问题的数学表达就是<br>$$\underset{W,b}{min}J(W) = \underset{W,b}{min}\frac 1 2 ||W||^2 \\\\<br>s.t.\quad y_i(X_i^TW+b) \ge 1, i=1,2,…n. \tag{2.2.4}<br>$$</p>
<p>通过求解上式即可得到最优超平面 $ \hat{W} $ 和 $ \hat{b} $ 。具体如何求解见2.4和2.5节。</p>
<h3 id="2-3-支持向量"><a href="#2-3-支持向量" class="headerlink" title="2.3 支持向量"></a>2.3 支持向量</h3><p>在线性可分的情况下，训练数据集的样本点中与分离超平面距离最近的数据点称为支持向量(support vector)，支持向量是使$(2.2.4)$中的约束条件取等的点，即满足<br>$$<br> y_i(X_i^TW+b) = 1 \tag{2.3.1}<br>$$<br>的点。也即所有在直线$ X^TW+b = 1$或直线$ X^TW+b = -1$的点。如下图所示:</p>
<center><br>    <img src="/2018/10/27/SVM/2.2.png" width="400"><br>    <br><br>    <div style="border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;">图2.2</div><br></center>

<p><strong>在决定最佳超平面时只有支持向量起作用，而其他数据点并不起作用</strong>(具体推导见2.4节最后)。如果移动非支持向量，甚至删除非支持向量都不会对最优超平面产生任何影响。也即支持向量对模型起着决定性的作用，这也是“支持向量机”名称的由来。</p>
<h3 id="2-4-对偶问题"><a href="#2-4-对偶问题" class="headerlink" title="2.4 对偶问题"></a>2.4 对偶问题</h3><p>如何求解式 $(2.2.4)$ 呢？</p>
<p>我们称式 $(2.2.4)$ 所述问题为原始问题(primal problem), 可以应用拉格朗日乘子法构造拉格朗日函数(Lagrange function)再通过求解其对偶问题(dual problem)得到原始问题的最优解。转换为对偶问题来求解的原因是:</p>
<ul>
<li>对偶问题更易求解，由下文知对偶问题只需优化一个变量$\alpha$且约束条件更简单；</li>
<li>能更加自然地引入核函数，进而推广到非线性问题。</li>
</ul>
<p>首先构建拉格朗日函数。为此需要引进拉格朗日乘子(Lagrange multiplier) $\alpha_i \ge 0, i=1,2,…n$。则拉格朗日函数为:<br>$$<br>L(W,b,\alpha)=\frac 1 2 ||W||^2 - \sum_{i=1}^n \alpha_i [y_i(X_i^TW+b)-1]<br>\tag{2.4.1}<br>$$<br>因此，给定一个$W$和$b$, 若不满足式$(2.2.4)$的约束条件，那么有<br>$$<br>\underset{\alpha}{max} L(W,b,\alpha) = +\infty \tag{2.4.2}<br>$$<br>否则，若满足式$(2.2.4)$的约束条件，有<br>$$<br>\underset{\alpha}{max} L(W,b,\alpha) = J(W) = \frac 1 2 ||W||^2 \tag{2.4.3}<br>$$<br>结合式$(2.4.2)$和$(2.4.3)$知，优化问题<br>$$<br>\underset{W, b}{min} \underset{\alpha}{max} L(W,b,\alpha)\tag{2.4.4}<br>$$<br>与式$(2.2.4)$所述问题是完全等价的。</p>
<p>根据拉格朗日对偶性，式$(2.4.4)$所述问题即原始问题的对偶问题是:<br>$$<br>\underset{\alpha}{max} \underset{W, b}{min} L(W,b,\alpha) \tag{2.4.5}<br>$$</p>
<blockquote>
<p>以上具体推导细节可参见书籍《统计学习方法》或者知乎文章<a href="https://zhuanlan.zhihu.com/p/38182879" target="_blank" rel="noopener">拉格朗日对偶性</a></p>
</blockquote>
<p>为了求得对偶问题的解，需要先求得$L(W,b,\alpha)$对$W$和$b$的极小再求对$\alpha$的极大。</p>
<p>(1) 求$\underset{W, b}{min} L(W,b,\alpha)$:<br>对拉格朗日函数求导并令导数为0，有:<br>$$<br>\nabla_W L(W,b,\alpha) = W - \sum_{i=1}^n \alpha_i y_i X_i = 0 \implies W= \sum_{i=1}^n \alpha_i y_i X_i\tag{2.4.6}<br>$$<br>$$<br>\nabla_b L(W,b,\alpha) = - \sum_{i=1}^n \alpha_i y_i = 0 \implies \sum_{i=1}^n \alpha_i y_i = 0 \tag{2.4.7}<br>$$<br>将上面两式代入$L(W,b,\alpha)$：</p>
<center><br>    <img src="/2018/10/27/SVM/fomula_1.png" width="500px"><br></center>

<p>所以，<br>$$<br>\underset{W, b}{min} L(W,b,\alpha) = -\frac 1 2 \sum_{i=1}^n \sum_{j=1}^n \alpha_i \alpha_j y_i y_j X_i^T X_j \ + \ \sum_{i=1}^n \alpha_i \tag{2.4.8}<br>$$</p>
<p>(2) 求$\underset{W, b}{min} L(W,b,\alpha)$ 对$\alpha$的极大:<br>等价于式$(2.4.8)$对$\alpha$求极大，也等价于式$(2.4.8)$取负数后对$\alpha$求极小，即<br>$$<br>\underset{\alpha}{min}  \quad  \frac 1 2 \sum_{i=1}^n \sum_{j=1}^n \alpha_i \alpha_j y_i y_j X_i^T X_j \ - \ \sum_{i=1}^n \alpha_i  \tag{2.4.9}<br>$$<br>同时满足约束条件:<br>$$<br>\sum_{i=1}^n \alpha_i y_i = 0 \\\\<br>\alpha_i \ge 0, i=1,2,…,n. \tag{2.4.10}<br>$$</p>
<p>至此，我们得到了原始最优化问题$(2.2.4)$和对偶最优化问题$(2.4.9)$、$(2.4.10)$。</p>
<p>由slater条件知，因为原始优化问题的目标函数和不等式约束条件都是凸函数，并且该不等式约束是严格可行的(因为数据是线性可分的), 所以存在 $ \hat{W} $, $ \hat{b}$ ,$\hat{\alpha} $，使得$ \hat{W} $, $ \hat{b}$是原始问题的解，$\hat{\alpha} $是对偶问题的解。这意味着求解原始最优化问题$(2.2.4)$可以转换为求解对偶最优化问题$(2.4.9)$、$(2.4.10)$。</p>
<blockquote>
<p>slater 条件:<br>原始问题一般性表达为<br>$$<br>\underset{x}{min} \quad f(x) \\\\<br>s.t. \ c_i(x) \le 0, i=1,2,…k \\\\<br>\quad \quad h_j(x) = 0, j=1,2,…,l<br>$$<br>则其拉格朗日函数为<br>$$<br>L(x,\alpha,\beta)=f(x) + \sum_{i=1}^k \alpha_i c_i(x) +<br>\sum_{j=1}^l \beta_j h_j(x), \quad \alpha_i \ge 0<br>$$<br>假设原始问题目标函数 $f(x)$ 和不等式约束条件 $c_i(x)$都是凸函数，原始问题等式约束$h_j(x)$都是仿射函数，且不等式约束 $c_i(x)$是严格可行的，即存在 $x$ ，对所有 $i$ 都有 $c_i(x) &lt; 0$ ，则存在 $\hat{x} $, $\hat{\alpha} $, $\hat{\beta} $，使 $\hat{x} $ 是原始问题的解， $\hat{\alpha} $, $\hat{\beta} $是对偶问题的解。</p>
</blockquote>
<p>那么如何求解优化问题$(2.4.9)$、$(2.4.10)$的最优解 $\hat{\alpha}$ 呢？<br>不难发现这是一个二次规划问题，有现成的通用的算法来求解。</p>
<blockquote>
<p>事实上通用的求解二次规划问题的算法的复杂度正比于训练数据样本数，所以在实际应用中需要寻求更加高效的算法，例如序列最小优化(Sequential Minimal Optimiation, SMO)算法。</p>
</blockquote>
<p>假设我们现在求得了$(2.4.9)$、$(2.4.10)$的最优解 $\hat{\alpha}$，则根据式$(2.4.6)$可求得最优$\hat{W}$：<br>$$<br>\hat{W}= \sum_{i=1}^n \hat{\alpha}_i y_i X_i \tag{2.4.11}<br>$$<br>因为至少存在一个 $\hat{\alpha}_j &gt; 0$(若不存在，即 $\hat{\alpha}$ 全为0，则 $\hat{W}=0$, 即 $margin = \frac 2 {||\hat{W}||}= \infty $,显然不行), 再根据KKT条件，即<br>$$<br>\begin{cases}<br>乘子非负: \alpha_i \ge 0 (i=1,2,…n.下同) \\\\<br>约束条件:  y_i(X_i^TW+b) - 1\ge 0 \\\\<br>互补条件:  \alpha_i (y_i(X_i^TW+b) - 1)=0<br>\end{cases}<br>$$<br>所以至少存在一个 $j$ , 使  $ y_j(X_j^T \hat{W}+\hat{b}) - 1=0$, 即可求得最优 $\hat{b}$:<br>$$<br>\begin{aligned}<br>\hat{b} &amp; = \frac 1 {y_j} -X_j^T \hat{W} \\\\<br>&amp; = y_j -X_j^T \hat{W} \\\\<br>&amp; = y_j-\sum_{i=1}^n \hat{\alpha}_i y_i X_j^T X_i<br>\end{aligned} \tag{2.4.12}<br>$$<br>至此，所以我们就求得了整个线性可分SVM的解。求得的分离超平面为:<br>$$<br>\sum_{i=1}^n \hat{\alpha}_i y_i X^TX_i + \hat{b}=0 \tag{2.4.13}<br>$$<br>则分类的决策函数为<br>$$<br>f(X) = sign(\sum_{i=1}^n \hat{\alpha}_i y_i X^TX_i + \hat{b})<br>\tag{2.4.14}<br>$$<br>再来分析KKT条件里的互补条件，对于任意样本 $(X_i, y_i)$ ，总会有 $ \alpha_i=0 $ 或者 $y_if(X_i)=y_i(X_i^T \hat{W}+b) = 1$。则有</p>
<ul>
<li>若$ \alpha_i=0$，此样本点不是支持向量，对模型没有任何作用；</li>
<li>若$ \alpha_i&gt;0$，此样本点位于最大间隔边界上，是一个支持向量，如下图所示。<center><br>  <img src="/2018/10/27/SVM/2.3.png" width="500"><br>  <br><br>  <div style="border-bottom: 1px solid #d9d9d9;
  display: inline-block;
  color: #999;">图2.3</div><br></center>

</li>
</ul>
<p>此外，当样本点是非支持向量时，因为$ \alpha_i=0$, 所以SVM的解中的求和项中第 $i$ 项就为0，所以SVM的解$(2.4.11)$、$(2.4.12)$可简化为如下形式:<br>$$<br>\hat{W}= \sum_{i \in SV} \hat{\alpha}_i y_i X_i \tag{2.4.15}<br>$$<br>$$<br>\hat{b} = y_j-\sum_{i \in SV} \hat{\alpha}_i y_i X_j^T X_i<br>\tag{2.4.16}<br>$$<br>类似的，判别函数也可转换成如下形式:<br>$$<br>f(X) = sign(\sum_{i \in SV} \hat{\alpha}_i y_i X^TX_i + \hat{b})<br>\tag{2.4.17}<br>$$<br>所以，整个SVM的解只与支持向量SV有关，与非支持向量无关。这也就解释了2.3节的结论，即在决定最佳超平面时只有支持向量起作用，而其他数据点并不起作用。</p>
<h2 id="3-线性SVM——软间隔"><a href="#3-线性SVM——软间隔" class="headerlink" title="3. 线性SVM——软间隔"></a>3. 线性SVM——软间隔</h2><p>在前面的讨论中，我们一直假定训练数据是严格线性可分的，即存在一个超平面能完全将两类数据分开。但是现实任务这个假设往往不成立，例如下图所示的数据。</p>
<center><br>    <img src="/2018/10/27/SVM/3.1.png" width="300"><br>    <br><br>    <div style="border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;">图3.1</div><br></center>

<h3 id="3-1-软间隔最大化"><a href="#3-1-软间隔最大化" class="headerlink" title="3.1 软间隔最大化"></a>3.1 软间隔最大化</h3><p>解决该问题的一个办法是允许SVM在少量样本上出错，即将之前的硬间隔最大化条件放宽一点，为此引入“软间隔(soft margin)”的概念。即允许少量样本不满足约束<br>$$<br>y_i(X_i^TW+b) \ge 1 \tag{3.1.1}<br>$$<br>为了使不满足上述条件的样本点尽可能少，我们需要在优化的目标函数$(2.2.2)$里面新增一个对这些点的惩罚项。最常用的是hinge损失:<br>$$<br>l_{hinge}(z) = max(0, 1-z) \tag{3.1.2}<br>$$<br>即若样本点满足约束条件损失就是0, 否则损失就是 $1-z$ ,则优化目标 $(2.2.2)$ 变成<br>$$<br>\underset{W,b}{min} \quad \frac 1 2 ||W||^2 + C \sum_{i=1}^n max(0, 1 - y_i(X_i^TW+b))<br>\tag{3.1.3}<br>$$<br>其中 $C &gt; 0$ 称为惩罚参数，$C$ 越小时对误分类惩罚越小，越大时对误分类惩罚越大，当 $C$ 取正无穷时就变成了硬间隔优化。实际应用时我们要合理选取 $C$，$C$ 越小越容易欠拟合，$C$ 越大越容易过拟合。</p>
<p>如果我们引入“松弛变量” $ \xi_i \ge 0$, 那么式 $(3.1.3)$ 可重写成<br>$$<br>\underset{W,b,\xi}{min} \quad \frac 1 2 ||W||^2 +  C \sum_{i=1}^n \xi_i\\\\<br>s.t.\ y_i(X_i^TW+b) \ge 1-\xi_i \\\\<br>\xi_i \ge 0, i=1,2,…n. \tag{3.1.4}<br>$$<br>上式所述问题即软间隔支持向量机。</p>
<h3 id="3-2-对偶问题"><a href="#3-2-对偶问题" class="headerlink" title="3.2 对偶问题"></a>3.2 对偶问题</h3><p>式 $(3.1.4)$ 表示的软间隔支持向量机依然是一个凸二次规划问题，和硬间隔支持向量机类似，我们可以通过拉格朗日乘子法将其转换为对偶问题进行求解。<br>式 $(3.1.4)$ 对应的拉格朗日函数为<br>$$<br>L(W,b,\xi,\alpha,\beta)=\frac 1 2 ||W||^2 + C \sum_{i=1}^n \xi_i - \sum_{i=1}^n \alpha_i [y_i(X_i^TW+b) - 1 + \xi_i] - \sum_{i=1}^n \beta_i \xi_i<br>\tag{3.2.1}<br>$$<br>类似2.4节，为了求得对偶问题的解，我们需要先求得$L(W,b,\xi,\alpha,\beta)$对 $W$、$b$ 和 $\xi$ 的极小再求对 $\alpha$ 和 $\beta$ 的极大。</p>
<blockquote>
<p>以下两步和2.4节几乎完全一样，除了最后对 $\alpha$ 的约束条件略有不同。 </p>
</blockquote>
<p>(1) 求$\underset{W, b, \xi}{min} L(W,b,\xi,\alpha,\beta)$:<br>将 $L(W,b,\xi,\alpha,\beta)$ 分别对 $W$、$b$ 和 $\xi$ 求偏导并令为0可得<br>$$<br>W=\sum_{i=1}^n \alpha_i y_i X_i \tag{3.2.2}<br>$$<br>$$<br>\sum_{i=1}^n \alpha_i y_i = 0 \tag{3.2.3}<br>$$<br>$$<br>C = \alpha_i + \beta_i \tag{3.2.4}<br>$$<br>将上面三个式子代入式 $(3.2.1)$ 并进行类似式 $(2.4.8)$ 的推导即得<br>$$<br>\underset{W, b, \xi}{min} L(W,b,\xi,\alpha,\beta) =<br>-\frac 1 2 \sum_{i=1}^n \sum_{j=1}^n \alpha_i \alpha_j y_i y_j X_i^T X_j \ + \ \sum_{i=1}^n \alpha_i \tag{3.2.5}<br>$$<br>注意其中的 $\beta$ 被消去了。</p>
<p>(2) 求$\underset{W, b, \xi}{min} L(W,b,\xi,\alpha,\beta)$对 $\alpha$ 的极大：<br>式$(3.2.5)$对$\alpha$求极大，也等价于式$(3.2.5)$取负数后对$\alpha$求极小，即<br>$$<br>\underset{\alpha}{min}  \quad  \frac 1 2 \sum_{i=1}^n \sum_{j=1}^n \alpha_i \alpha_j y_i y_j X_i^T X_j \ - \ \sum_{i=1}^n \alpha_i  \tag{3.2.6}<br>$$<br>同时满足约束条件:<br>$$<br>\sum_{i=1}^n \alpha_i y_i = 0 \\\\<br>\quad 0 \le \alpha_i \le C, i=1,2,…,n. \tag{3.2.7}<br>$$</p>
<p>至此，我们得到了原始最优化问题$(3.1.4)$和对偶最优化问题$(3.2.6)$、$(3.2.7)$。</p>
<p>类似2.4节地，假设我们现在通过通用的二次规划求解方法或者SMO算法求得了$(3.2.6)$、$(3.2.7)$的最优解 $\hat{\alpha}$，则根据式$(3.2.2)$可求得最优$\hat{W}$：<br>$$<br>\hat{W}= \sum_{i=1}^n \hat{\alpha}_i y_i X_i \tag{3.2.8}<br>$$<br>再根据KKT条件，即<br>$$<br>\begin{cases}<br>乘子非负: \alpha_i \ge 0 ,\enspace \beta_i \ge 0 (i=1,2,…n.下同)\\\\<br>约束条件:  y_i(X_i^TW+b) - 1\ge \xi_i \\\\<br>互补条件:  \alpha_i [y_i(X_i^TW+b) - 1+\xi_i]=0, \enspace \beta_i \xi_i=0<br>\end{cases}<br>$$<br>可求得整个软间隔SVM的解，即:<br>$$<br>\hat{W}= \sum_{i \in SV} \hat{\alpha}_i y_i X_i \tag{3.2.9}<br>$$<br>$$<br>\hat{b} = y_j-\sum_{i \in SV} \hat{\alpha}_i y_i X_j^T X_i<br>\tag{3.2.10}<br>$$<br>其中 $j$ 需满足 $0 &lt; \hat{\alpha}_j &lt; C$ 。</p>
<p>对于任意样本 $(X_i, y_i)$ ，</p>
<ul>
<li>若 $ \alpha_i=0$，此样本点不是支持向量，该样本对模型没有任何的作用；</li>
<li>若 $ \alpha_i&gt;0$，此样本是一个支持向量。</li>
</ul>
<p>若满足 $ \alpha_i&gt;0$ ，进一步地， </p>
<ul>
<li>若 $ 0 &lt; \alpha_i &lt; C$, 由式 $(3.2.4)$ 得 $\beta_i = 0$，即刚好 $y_i(X_i^TW+b) =1$，样本恰好在最大间隔边界上；</li>
<li>若 $\alpha_i = C$，有$\beta_i &gt; 0$，此时若 $\beta_i &lt; 1$则该样本落在最大间隔内部，若 $\beta_i &gt; 1$ 则该样本落在最大间隔内部即被错误分类。</li>
</ul>
<p>如下图所示。</p>
<center><br>    <img src="/2018/10/27/SVM/3.2.png" width="600"><br>    <br><br>    <div style="border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;">图3.2</div><br></center>

<p>因此，我们有与2.4节相同的结论，最优超平面只与支持向量有关而与非支持向量无关。</p>
<h3 id="3-3-惩罚参数-C"><a href="#3-3-惩罚参数-C" class="headerlink" title="3.3 惩罚参数 $C$"></a>3.3 惩罚参数 $C$</h3><p>对于不同惩罚参数 $C$，SVM结果如下图所示。</p>
<center><br>    <img src="/2018/10/27/SVM/3.3.png" width="900"><br>    <br><br>    <div style="border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;">图3.3</div><br></center>

<p>再来看看我们的原始目标函数:<br>$$<br>\underset{W,b,\xi}{min} \quad \frac 1 2 ||W||^2 +  C \sum_{i=1}^n \xi_i<br>$$</p>
<p>对于更加一般化的问题，可将上述式子抽象成：<br>$$<br>\underset{f}{min} \quad \Omega(f) +  C \sum_{i=1}^n l(f(x_i),y_i) \tag{3.3.1}<br>$$<br>前一项可以理解为“结构风险(structural risk)”，用来描述所求模型的某些性质(SVM就是要求间隔最大)；第二项称为“经验风险(empirical risk)”，用来描述模型与训练数据的契合程度(即误差)。而参数 $C$ 就是用于对二者的折中,即我们一方面要求模型要满足某种性质另一方面又想使模型与训练数据很契合。</p>
<p>从正则化角度来讲， $\Omega(f)$ 称为正则化项，$C$ 称为惩罚参数，$C$ 越大即对误分类的惩罚越大(要求模型对训练模型更契合)，这可能会存在过拟合；$C$ 越小即相对更加看重正则化项，此时可能存在欠拟合。</p>
<h2 id="4-非线性SVM——核技巧"><a href="#4-非线性SVM——核技巧" class="headerlink" title="4. 非线性SVM——核技巧"></a>4. 非线性SVM——核技巧</h2><p>前面介绍的都是线性问题，但是我们经常会遇到非线性的问题(例如异或问题)，此时就需要用到核技巧(kernel trick)将线性支持向量机推广到非线性支持向量机。需要注意的是，不仅仅是SVM，很多线性模型都可以用核技巧推广到非线性模型，例如核线性判别分析(KLDA)。</p>
<h3 id="4-1-核函数"><a href="#4-1-核函数" class="headerlink" title="4.1 核函数"></a>4.1 核函数</h3><p>如下图所示，核技巧的基本思路分为两步:</p>
<ul>
<li>使用一个变换将原空间的数据映射到新空间(例如更高维甚至无穷维的空间)；</li>
<li>然后在新空间里用线性方法从训练数据中学习得到模型。</li>
</ul>
<center><br>    <img src="/2018/10/27/SVM/4.1.png" width="600"><br>    <br><br>    <div style="border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;">图4.1</div><br></center>

<p>怎样映射到特征空间？</p>
<p>先来看看核函数的定义，</p>
<blockquote>
<p>设 $\mathcal{X}$ 是输入空间(欧式空间$R^n$的子集或离散集合)，又设 $\mathcal{H}$ 是特征空间(希尔伯特空间)，如果存在一个 $\mathcal{X}$ 到 $\mathcal{H}$ 的映射<br>$$<br>\phi(x): \mathcal{X} \to \mathcal{H}<br>$$<br>使得对所有 $x,z \in \mathcal{X}$，函数 $K(x,z)$ 满足条件<br>$$<br>K(x,z)=\phi(x) \cdot \phi(z)<br>$$<br>则称 $K(x,z)$ 为核函数， $\phi(x)$ 为映射函数，式中 $\phi(x) \cdot \phi(z)$ 为 $\phi(x)$ 和 $\phi(z)$ 的內积。</p>
</blockquote>
<p>通常，直接计算 $K(x,z)$ 比较容易而通过 $\phi(x)$ 和 $\phi(z)$ 计算 $K(x,z)$ 并不容易。而幸运的是，在线性支持向量机的对偶问题中，无论是目标函数还是决策函数都只涉及到输入样本与样本之间的內积，因此我们不需要显式地定义映射 $\phi(x)$ 是什么而只需事先定义核函数 $K(x,z)$ 即可。也就是说，在核函数 $K(x,z)$ 给定的情况下，可以利用解线性问题的方法求解非线性问题的支持向量机，此过程是隐式地在特征空间中进行的。</p>
<h3 id="4-2-正定核"><a href="#4-2-正定核" class="headerlink" title="4.2 正定核"></a>4.2 正定核</h3><p>由上面的介绍可知，我们只需要定义核函数就可以了。但是如何不通过映射 $\phi(x)$ 判断给定的一个函数 $K(x,z)$ 是不是核函数呢？或者说，$K(x,z)$ 需要满足什么条件才是一个核函数。  </p>
<p>通常所说的核函数就是正定核函数，下面不加证明的给出正定核的充要条件，具体证明略显复杂，有兴趣的可以参考《统计学习方法》。</p>
<blockquote>
<p>设 $\mathcal{X} \subset R^n$ ,$K(x,z)$ 是定义在 $\mathcal{X} \times \mathcal{X}$ 上的对称函数，如果对任意的 $x_i \in \mathcal{X}, i=1,2,…,m$，$K(x,z)$ 对应的Gram矩阵<br>$$<br>K = [K(x_i, x_j)]_{m \times m}<br>$$<br>是半正定矩阵，则 $K(x,z)$ 是正定核。</p>
</blockquote>
<p>虽然有了上述定义，但是实际应用时验证 $K(x,z)$ 是否是正定核依然不容易，因此在实际问题中一般使用已有的核函数，下面给出一些常用的核函数。 </p>
<ul>
<li><p>多项式核函数(polynomial kernel function)<br>$$<br>K(x,z) = (x \cdot z + 1)^p \tag{4.2.1}<br>$$</p>
</li>
<li><p>高斯核函数(Guassian kernel function)<br>$$<br>K(x,z) = exp(- \frac {||x-z||^2} {2 \sigma^2} ) \tag{4.2.2}<br>$$</p>
</li>
</ul>
<h3 id="4-3-非线性支持向量机"><a href="#4-3-非线性支持向量机" class="headerlink" title="4.3 非线性支持向量机"></a>4.3 非线性支持向量机</h3><p>如前4.1、4.2所述，利用核技巧可以很简单地把线性支持向量机扩展到非线性支持向量机，只需将线性支持向量机中的內积换成核函数即可。下面简述非线性支持向量机学习算法。</p>
<ul>
<li><p>首先选取适当的核函数 $K(x,z)$ 和适当的参数 $C$，构造最优化问题<br>$$<br>\begin{aligned}<br>&amp; \underset{\alpha}{min}  \quad  \frac 1 2 \sum_{i=1}^n \sum_{j=1}^n \alpha_i \alpha_j y_i y_j K(X_i,X_j) \ - \ \sum_{i=1}^n \alpha_i \\\\<br>&amp; s.t. \quad \sum_{i=1}^n \alpha_i y_i = 0 \\\\<br>&amp; \qquad 0 \le \alpha_i \le C, i=1,2,…,n.<br>\end{aligned} \tag{4.3.1}<br>$$<br>再利用现成的二次规划问题求解算法或者SMO算法求得最优解 $\hat{\alpha}$ 。</p>
</li>
<li><p>选择 $\hat{\alpha}$ 的一个满足 $0 &lt; \hat{\alpha}_j &lt; C$ 的分量 $\hat{\alpha}_j$ ，计算<br>$$<br>\hat{b} = y_j-\sum_{i \in SV} \hat{\alpha}_i y_i K(X_j,X_i)<br>\tag{4.3.2}<br>$$</p>
</li>
<li><p>构造决策函数：<br>$$<br>f(x)=sign(\sum_{i \in SV}\hat{\alpha}_i y_i K(X_j,X_i) + \hat{b}) \tag{4.3.3}<br>$$</p>
</li>
</ul>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>任何算法都有其优缺点，支持向量机也不例外。</p>
<p>支持向量机的优点是:</p>
<blockquote>
<ol>
<li>由于SVM是一个凸优化问题，所以求得的解一定是全局最优而不是局部最优。</li>
<li>不仅适用于线性线性问题还适用于非线性问题(用核技巧)。</li>
<li>拥有高维样本空间的数据也能用SVM，这是因为数据集的复杂度只取决于支持向量而不是数据集的维度，这在某种意义上避免了“维数灾难”。</li>
<li>理论基础比较完善(例如神经网络就更像一个黑盒子)。</li>
</ol>
</blockquote>
<p>支持向量机的缺点是:</p>
<blockquote>
<ol>
<li>二次规划问题求解将涉及m阶矩阵的计算(m为样本的个数), 因此SVM不适用于超大数据集。(SMO算法可以缓解这个问题)</li>
<li>只适用于二分类问题。(SVM的推广SVR也适用于回归问题；可以通过多个SVM的组合来解决多分类问题)</li>
</ol>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/assets/header.jpg"
                alt="TangShusen" />
            
              <p class="site-author-name" itemprop="name">TangShusen</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/shusentang" title="GitHub &rarr; https://github.com/shusentang" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TangShusen</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.5.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  

  

  
  

  
  
    
      
        
      
    
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    
  


  
  

  

  

  

  

  

  

</body>
</html>
